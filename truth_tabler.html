class Operator {

	constructor(priority, syntax, func, input, output){
		this.priority   = priority;
		this.syntax     = syntax;
		this.func   	  = func;
		this.input 	    = input;
		this.output 	  = output;
		
	}
	
	function position(){
	  for(i = 0; i < input.length; i++){
	    if(input[i] === null){
	      return i;
	    }
	  }
	}

}

function nand (input){return !(input[0] & input[1]);                            }
function and  (input){return input[0] && input[1];                              }
function xor  (input){return (input[0] || input[1]) && !( input[0] && input[1]);}
function or   (input){return input[0] || input[1];                              }
function not  (input){return !input[0];                                         }

var operator_nand = new Operator(2, "!&", nand, [Boolean, null, Boolean], Boolean);
var operator_and =  new Operator(2, "&&", and, [Boolean, null, Boolean],  Boolean);
var operator_xor =  new Operator(2, "||", xor, [Boolean, null, Boolean],  Boolean);
var operator_or =   new Operator(2, "|", or, [Boolean, null, Boolean],    Boolean);
var operator_not =  new Operator(1, "!", not, [null, Boolean],            Boolean);

var operators = [];
operators.push(operator_nand);
operators.push(operator_and);
operators.push(operator_xor);
operators.push(operator_or);
operators.push(operator_not);

class Variable {
  
  constructor(name, type, value){
    this.name = name;
    this.type = type;
    this.value = value;
  }
  
}

var uniqueArray = function(arrArg) {
  return arrArg.filter(function(elem, pos,arr) {
    return arr.indexOf(elem) == pos;
  });
};


function expression_get_length(expression, start){
  if(expression[start] == '('){
    
    var counter = 0;
    var i = start;
    
    do{
      
      if(expression[i] == '('){
        counter++;
      }else if(expression[i] == ')'){
        counter--;
      }
      i++
    }while(!(counter == 0) && (i < expression.length));
    
    if(counter === 0){
      return i-start;
    }else{
      console.log("error: no closing parenthesis at " + start);  
    }
    
  }else{
    return expression.length - start;
  }
}

function expression_is_operator(expression, i){
  for(j = 0; j < operators.length; j++){
    for(k = 0; k < operators[j].syntax.length; k++){
      var sbstr = expression.substring(i, i+operators[j].syntax.length);
      
      if(sbstr == operators[j].syntax){
        console.log("found operator: " + operators[j].syntax);
        return true;
      }
    }  
  }
  return false;
}
function expression_is_space(expression, i){
  return expression[i] == ' ';
}
function expression_is_variable(expression, i){
  return expression[i].match(/[A-Za-z]/g);
}
function expression_is_nested_expression(expression, i){
  return expression[i] == '(';
}
function expression_get_operator(expression, i){
  for(j = 0; j < operators.length; j++){
    for(k = 0; k < operators[j].syntax.length; k++){
      var sbstr = expression.substring(i, i+operators[j].syntax.length);
      if(sbstr == operators[j].syntax){
        // console.log("got operator: " + operators[j].syntax);
        return operators[j];
      }
    }  
  }  
}
function expression_get_variable(expression, i){
  var variable_name = new String('');
  for(j = i; j < expression.length; j++){
    if(expression[j].match(/[A-Za-z]/g)){
      variable_name += expression[j];
    }else{
      break;
    }
  }
  return variable_name;
}

function variable_resolve(variable_name, variables){
  for(i = 0; i < variables.length; i++){
    if(variable_name == variables[i].name){
      return variables[i];
    }
  }
  console.log("error: unable to resolve " + variable_name);
  return null;
}

function isVariable(element){
  return element instanceof Variable;
}

function isArray(element){
  return element instanceof Array;
}

function isOperator(element){
  return element instanceof Operator;
}

function compilerException(location, expected){
  this.name = "compilerException";
  this.location = location;
  this.expected = expected;
}

function hasPriority(element, i){
  if(isOperator(element)){  
    return element.priority == i;
  }else{
    throw compilerException("hasPriority()", 
                            "element is an operator");
  }
}

function syntaxException(message, actual, expected){
  this.name = "Syntax Exception";
  this.message = message;
  this.expected = expected;
  this.actual = actual;
}

function isVariableSameAsType(variable, type){
    return variable instanceof type;
}

function scope_check_syntax(scope, operators, n=1){
 
  if(scope.length == 1){
    return scope[0];
  }

  for(i = 0; i < scope.length; i++){ 
    if(isArray(scope[i])){
      try{
        scope[i] = scope_check_syntax(scope[i], operators, n+1);
      }catch(error){
        throw error;
      }
      
    } else if (isVariable(scope[i])){
      scope[i] = scope[i].type;
      console.log(scope);
    }
  }
  
  var has_operator = true;
  var priority = 0;

  
  while(has_operator){
    has_operator = false;
    
    // Find the operator in the scope
    for(i = 0; i < scope.length; i++){
      
      if(isOperator(scope[i])){
        has_operator = true;
      }
      
      
      if(isOperator(scope[i]) && hasPriority(scope[i], priority)){
        
        // (i) is the operators positon in the scope
        // (operator_position) is the positon in the operators syntax
        var operator_position; 
        var operator_length = scope[i].input.length; 
        
        // we need the syntax for the opeator
        // e.g. "True   ==   Bool"
        // or   [Bool][Null][Bool]
        //        0     1     2
        //      operator_length    :3
        //      operator_position  :1
        for(j = 0; j < operator_length; j++){
          if(scope[i].input[j] == null){
            operator_position = j;
            break;
          } 
        } 
        
        // we check that we have enough arguments for the opeator
        // Expected: [Bool][Null][Bool]
        // Actual:   [Bool][Null]
        var scope_length = scope.length;
        if(scope_length < operator_length){
          throw syntaxException("too few arguments for " + cs[i].syntax, 
                                "requires "              + cs[i].operator_length,
                                "has "                   + scope_length);
        }
        
        // we check that the operators have order of the syntax is good
        // Expected: [Bool][Null][Bool] -> i - operator_position = 1 - 1 =  0
        // Actual:   [Null][Bool][Bool] -> i - operator_position = 0 - 1 = -1
        var start_position = i - operator_position;
        if(start_position < 0){
          throw syntaxException("incorrect syntax for the operator", "", "");
        }
        
        // we check that the operators syntax matches the expression
        // Expected: [Bool][Null][Bool]
        // Actual:   [Int][Bool][Null]
        for(j = 0; j < operator_length; j++){
          if(scope[i].input[j] == null){
            // Expect: [==]
            if(!scope[i] === scope[j+start_position]){
              // Actual: [Bool]
              throw compilerException(
                "scope_check_syntax()",
                "never will be executed",
                "was executed");
            }
          
          }else{
            
            // Expect: [Bool]
            if(!scope[j+start_position] === scope[i].input[j]){
              //Actual: ![Bool]
              console.log("incorrect argument");
              throw syntaxException(
                "incorrect argument", scope[i].input[j], typeof scope[j+start_position]);
            }else{
              // Actual: [Bool]
            }
          } 
          
        }
        
        //replace the input(s) with the output
        var output = scope[i].output;
        var spliced = scope.splice(start_position, scope_length, output);
      
      }
      
      
    }
    
    priority++;
  }

  return scope;
    
}

function evaluate_expression(expression, variables, operators, start){
  var length = expression_get_length(expression, start);
  var i = start;
  var clipped_expression = expression.substring(start, start+length);
  var expect_parenthesis = false;
  
  if(expression[start] == '('){
    expect_parenthesis = true;
    i++;
  }
  
  var scope = [];
  for(; i < start+length; i++){
    if(expression_is_nested_expression(expression, i)){
      scope.push(expression_evaluate(expression, variables, operators, i)); //scope.push();
      i += expression_get_length(expression, i);
    }else if(expression_is_operator(expression, i)){
      var operator = expression_get_operator(expression, i);
      scope.push(operator);
      i += operator.syntax.length;
    }else if(expression_is_variable(expression, i)){
      var variable_name = expression_get_variable(expression, i);
      var variable = variable_resolve(variable_name, variables);
      scope.push(variable);
      i += variable_name.length;
    }else if(expression_is_space(expression, i)){
      continue;
    }else{
      console.log("no fucking clue what " + expression[i] + " is.");
    }
  }
  
  
  return scope;
}


function make_variables(variable_names){
  var variables = [];
  for(i = 0; i < variable_names.length; i++){
    variables.push(new Variable(variable_names[i], Boolean, false));
  }
  return variables;
}

function fetch_variables(expression){
  var variables = expression.match(/[A-Za-z]+/g);
  variables = uniqueArray(variables);
  return variables;
}

function execute_expression(expression, variables, n=0){
  
  for(i = 0; i < expression.length; i++){
    if(isArray(expression[i])){
      expression[i] = execute_expression(expression[i], variables, n+1);
    }
  }
  
  for(i = 0; i < expression.length; i++){
    if(isVariable(expression[i])){
      expression[i] = expression[i].value;
    }
  }
  
  var foundOperator = true;
  for(p = 0; foundOperator; p++){
    foundOperator = false;
    for(i = 0; i < expression.length; i++){
      if(isOperator(expression[i])){
        if(expression[i].priority == p){
          var l = expression[i].input.length;
          var p = expression[i].position(); //operator position (relativly)
          var s = i - p;                    //start
          var inputs = [];
          for(j = s; j < s+l; j++){
            input.push(expression[j].)
          }
        }
      } 
    }
  }
  
}

function generate_powers(b, n){
  var column_vector = [];
  for(i = 0; i < n; i++){
    column_vector.push(b^i);
  }
  return column_vector;
}

function possible_combinations(s, n){
  return Math.pow(s, n);
}

function floor(x){
  return x - (x % 1);
}

function truth_table(expression){
    
    var variable_names = fetch_variables(expression);
    var variables = make_variables(variable_names);
    
		var parsable_expression = evaluate_expression(expression, variables, operators);
    
    var executable_expression = scope_check_syntax(parsable_expression, operators);
    
    var s = [false, true];                // possible inputs
    var b = s.length;                     // base
    var l = variables.length;             // total values
    var n = possible_combinations(b, l);  
    
    for(i = 0; i < n; i++){
      for(j = 0; j < l; j++){
        var index = floor((i/Math.pow(b,j)) % b);
        variables[j].value = s[index];
      }
      
      console.log(execute_expression(executable_expression, variables));
    }
    
    
}

function unit_test(){
  
}

unit_test();
truth_table("(!(A && B) || (D | (A || B))) & (A !& C)");
