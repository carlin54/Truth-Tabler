class operator {

	constructor(syntax, func, input, output){
		this.syntax = syntax;
		this.func 	= func;
		this.input 	= input;
		this.outout 	= output;
		
	}

}

function nand(a, b){
	return !(a & b);
}
function and(a, b){
	return a && b;
}
function xor(a, b){
  return ( a || b ) && !( a && b );
}
function or(a, b){
	return a || b;
}
function not(a){
	return !a;
}


var operator_nand 
= new operator("!&", nand, [Boolean, null, Boolean], [Boolean]);

var operator_and 
= new operator("&&", and, [Boolean, null, Boolean], [Boolean]);

var operator_xor 
= new operator("!&", xor, [Boolean, null, Boolean], [Boolean]);

var operator_or 
= new operator("|", or, [Boolean, null, Boolean], [Boolean]);

var operator_not 
= new operator("!", not, [null, Boolean], [Boolean]);


function next_operator(cursor_start, cursor_end, expression){
	
	
}

function print_segment(start, end, string){
	console.log(string, start, end);
}

function get_expression_length(start, expression){
	// possibly the whole thing
	if(expression[start] = '('){ 
		return expression.length() - start;
	}
	// nested expression
	for(i = 0; i < expression.length()-start; i++){
	  if(expression[start+i] == ')'){
			return i;
		} 
	}
}

// cursor 		:: int
// variables 	:: [[name, value],...]
// expression 	:: string
// return		:: [value, type]
function find_expression(cursor, variables, expression){
    // [start, end, value]
    var expression_length;
	
	var temp; //scope -> next a = temp
    var is_end_of_expression = false;
    var expected_parenthasis = false;
		for(i = cursor; i < expression.length() || is_end_of_expression; i++){    
    		if(expression[i] == '('){
        	// is nested expression
          if(expected_parentsis = true){
          	//find_next_operator = ()
            
          	evaluate_expression(i, variables, expression);
          
          }else{
          
          	expected_parenthsis = true;
          
          }
          
        }else if(expression[i] == ')'){
        	if(expected_parenthsis = true){
          	return temp;
          }
        }else if(expression[i] == 'A'){
        
        }
    }
    // iterate through the expression
    	// if variable
      	//expect operator
      //if parenthasises
      	//expect variable
       
}

function truth_table(expression){
		var answer = execute_expression(i, expression);
}
