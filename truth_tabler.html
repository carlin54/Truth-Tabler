class operator {

	constructor(priority, syntax, func, input, output){
		this.priority   = priority;
		this.syntax     = syntax;
		this.func   	  = func;
		this.input 	    = input;
		this.output 	  = output;
		
	}

}

function nand (a, b)  {return !(a & b);                 }
function and  (a, b)  {return a && b;                   }
function xor  (a, b)  {return ( a || b ) && !( a && b );}
function or   (a, b)  {return a || b;                   }
function not  (a)     {return !a;                       }

var operator_nand = new operator(2, "!&", nand, [Boolean, null, Boolean], [Boolean]);
var operator_and =  new operator(2, "&&", and, [Boolean, null, Boolean], [Boolean]);
var operator_xor =  new operator(2, "||", xor, [Boolean, null, Boolean], [Boolean]);
var operator_or =   new operator(2, "|", or, [Boolean, null, Boolean], [Boolean]);
var operator_not =  new operator(1, "!", not, [null, Boolean], [Boolean]);

var operators = [];
operators.push(operator_nand);
operators.push(operator_and);
operators.push(operator_xor);
operators.push(operator_or);
operators.push(operator_not);

class variable {
  
  constructor(name, type, value){
    this.name = name;
    this.type = type;
    this.value = value;
  }
  
}





function expression_execute(expression, variables){
  
}

function expression_get_length(expression, start){
  if(expression[start] == '('){
    
    var counter = 0;
    var i = start;
    
    do{
      
      if(expression[i] == '('){
        counter++;
      }else if(expression[i] == ')'){
        counter--;
      }
      i++
    }while(!(counter == 0) && (i < expression.length));
    
    if(counter === 0){
      return i-start;
    }else{
      console.log("error: no closing parenthesis at " + start);  
    }
    
  }else{
    return expression.length - start;
  }
}
function print_se(start, length){
  console.log("[" + start + "," + (start+length) + "] -> " + length);
}

// assumes sorted from max length min length
function expression_is_operator(expression, i){
  for(j = 0; j < operators.length; j++){
    for(k = 0; k < operators[j].syntax.length; k++){
      var sbstr = expression.substring(i, i+operators[j].syntax.length);
      
      if(sbstr == operators[j].syntax){
        console.log("found operator: " + operators[j].syntax);
        return true;
      }
    }  
  }
  return false;
}
function expression_is_space(expression, i){
  return expression[i] == ' ';
}
function expression_is_variable(expression, i){
  return expression[i].match(/[A-Za-z]/g);
}
function expression_is_nested_expression(expression, i){
  return expression[i] == '(';
}
function expression_get_operator(expression, i){
  for(j = 0; j < operators.length; j++){
    for(k = 0; k < operators[j].syntax.length; k++){
      var sbstr = expression.substring(i, i+operators[j].syntax.length);
      if(sbstr == operators[j].syntax){
        // console.log("got operator: " + operators[j].syntax);
        return operators[j];
      }
    }  
  }  
  // console.log("error: operator not found!")
}
function expression_get_variable(expression, i){
  var variable_name = new String('');
  for(j = i; j < expression.length; j++){
    if(expression[j].match(/[A-Za-z]/g)){
      variable_name += expression[j];
    }else{
      break;
    }
  }
  // console.log("got name: " + variable_name);
  return variable_name;
}



function variable_resolve(variable_name, variables){
  for(i = 0; i < variables.length; i++){
    if(variable_name == variables[i].name){
      return variables[i];
    }
  }
  console.log("error: unable to resolve " + variable_name);
  return null;
}

function scope_check_operators(scope, operators){
  // try to reduce the output to one type
  
  for(i = 0; i < scope.length; i++){
    console.log(scope[i].constructor); 
    
    if(scope[i].isArray){
      console.log("nested expression found!");
      scope[i] = scope_check_operators(scope[i]);
    }else if(scope[i].constructor == 'operator'){
      console.log("operator found!");
    }
  }
}


function expression_evaluate(expression, variables, operators, start){
  var length = expression_get_length(expression, start);
  var i = start;
  var clipped_expression = expression.substring(start, start+length);
  // console.log("open (\"" + clipped_expression +"\") -> [" + start + ", " + (start+length) + ", " + length + "]");
  var expect_parenthesis = false;
  
  if(expression[start] == '('){
    expect_parenthesis = true;
    i++;
  }
  
  var scope = [];
  for(; i < start+length; i++){
     console.log("parsing (" + i + "): " + expression[i]);
    
    if(expression_is_nested_expression(expression, i)){
      console.log("nested expression found jumping to " + "(\"" + expression[i] + "\")");
      scope.push(expression_evaluate(expression, variables, operators, i)); //scope.push();
      i += expression_get_length(expression, i);
      
      
    }else if(expression_is_operator(expression, i)){
      var operator = expression_get_operator(expression, i);
      scope.push(operator);
      i += operator.syntax.length;
      console.log("operator found: jumping to " + i + "(\"" + expression[i] + "\")");
      
    }else if(expression_is_variable(expression, i)){
      var variable_name = expression_get_variable(expression, i);
      var variable = variable_resolve(variable_name, variables);
      scope.push(variable);
      i += variable_name.length;
      console.log("variable found: jumping to " + i + "(\"" + expression[i] + "\")");
      
    }else if(expression_is_space(expression, i)){
      console.log("skipping " + i + " (\"" + expression[i] + "\")");
      continue;
    }else{
      console.log("no fucking clue what " + expression[i] + " is.");
    }
  }
  
  // scope_evaluate(scope, operators);
  
  // console.log("close (\"" + clipped_expression +"\")");
  
  scope_check_operators(scope, operators);
  
  
  return scope;
}


function truth_table_make_variables(variable_names){
  var variables = [];
  for(i = 0; i < variable_names.length; i++){
    variables.push(new variable(variable_names[i], Boolean, false));
  }
  return variables;
}

function truth_table_next_row(variables){
  
}

function truth_table_get_variables(expression){
  return expression.match(/[A-Za-z]+/g);
}

function truth_table(expression){
    var variable_names = truth_table_get_variables(expression);
    console.log("variable names: " + variable_names);
    var variables = truth_table_make_variables(variable_names);
		console.log("variables: ");
		console.log(variables);
		var error = expression_evaluate(expression, variables, operators, 0);
		//console.log(error);
}




truth_table("((A && B) || (D || C))");
