class operator {

	constructor(syntax, func, input, output){
		this.syntax = syntax;
		this.func 	= func;
		this.input 	= input;
		this.outout 	= output;
		
	}

}

class variable {
  
  constructor(name, type, value){
    this.name = name;
    this.type = type;
    this.value = value;
  }
  
}


function nand(a, b){
	return !(a & b);
}
function and(a, b){
	return a && b;
}
function xor(a, b){
  return ( a || b ) && !( a && b );
}
function or(a, b){
	return a || b;
}
function not(a){
	return !a;
}


var operator_nand 
= new operator("!&", nand, [Boolean, null, Boolean], [Boolean]);

var operator_and 
= new operator("&&", and, [Boolean, null, Boolean], [Boolean]);

var operator_xor 
= new operator("!&", xor, [Boolean, null, Boolean], [Boolean]);

var operator_or 
= new operator("|", or, [Boolean, null, Boolean], [Boolean]);

var operator_not 
= new operator("!", not, [null, Boolean], [Boolean]);


function expression_execute(expression, variables){
  
}

function expression_get_length(expression, start){
  console.log("start -> " + start);
  if(expression[start] == '('){
    
    var counter = 0;
    var i = start;
    
    do{
      
      console.log(i + " : " + expression[i]);
      if(expression[i] == '('){
        counter++;
      }else if(expression[i] == ')'){
        counter--;
      }
      i++
    }while(!(counter == 0) && (i < expression.length));
    
    if(counter === 0){
      return i-start;
    }else{
      console.log("error: no closing parenthesis at " + start);  
    }
    
  }else{
    return expression.length - start;
  }
}
function print_se(start, length){
  console.log("[" + start + "," + (start+length) + "] -> " + length);
}


function expression_evaluate(expression, start){
  var length = expression_get_length(expression, start);
  var i = start;
  
  console.log(expression.substring(start, start+length));
  var expect_parenthesis = false;
  print_se(start, length);
  
  
  if(expression[start] == '('){
    expect_parenthesis = true;
    i++;
  }
  
  for(; i < length-start; i++){
    if(expression[i] == '('){
      expression_evaluate(expression, i);      
    }
  }
  
  
  
}
function truth_table_make_variables(variable_names){
  var variables = [];
  for(i = 0; i < variable_names.length; i++){
    variables.push(new variable(variable_names[i], Boolean, false));
  }
  return variables;
}
function truth_table_next_row(variables){
  
}
function truth_table_get_variables(expression){
  return expression.match(/[A-Za-z]+/g);
}
function truth_table(expression){
    var variable_names = truth_table_get_variables(expression);
    console.log(variable_names);
    var variables = truth_table_make_variables(variable_names);
		console.log(variables);
		
		var error = expression_evaluate(expression, 0);
}



truth_table("((A && B) || (B || C))");

