class Operator {

	constructor(priority, syntax, func, input, output){
		this.priority   = priority;
		this.syntax     = syntax;
		this.func   	  = func;
		this.input 	    = input;
		this.output 	  = output;
		
	}

}

function nand (a, b)  {return !(a & b);                 }
function and  (a, b)  {return a && b;                   }
function xor  (a, b)  {return ( a || b ) && !( a && b );}
function or   (a, b)  {return a || b;                   }
function not  (a)     {return !a;                       }

var operator_nand = new Operator(2, "!&", nand, [Boolean, null, Boolean], [Boolean]);
var operator_and =  new Operator(2, "&&", and, [Boolean, null, Boolean],  [Boolean]);
var operator_xor =  new Operator(2, "||", xor, [Boolean, null, Boolean],  [Boolean]);
var operator_or =   new Operator(2, "|", or, [Boolean, null, Boolean],    [Boolean]);
var operator_not =  new Operator(1, "!", not, [null, Boolean],            [Boolean]);

var operators = [];
operators.push(operator_nand);
operators.push(operator_and);
operators.push(operator_xor);
operators.push(operator_or);
operators.push(operator_not);

class Variable {
  
  constructor(name, type, value){
    this.name = name;
    this.type = type;
    this.value = value;
  }
  
}





function expression_execute(expression, variables){
  
}

function expression_get_length(expression, start){
  if(expression[start] == '('){
    
    var counter = 0;
    var i = start;
    
    do{
      
      if(expression[i] == '('){
        counter++;
      }else if(expression[i] == ')'){
        counter--;
      }
      i++
    }while(!(counter == 0) && (i < expression.length));
    
    if(counter === 0){
      return i-start;
    }else{
      console.log("error: no closing parenthesis at " + start);  
    }
    
  }else{
    return expression.length - start;
  }
}
function print_se(start, length){
  console.log("[" + start + "," + (start+length) + "] -> " + length);
}

// assumes sorted from max length min length
function expression_is_operator(expression, i){
  for(j = 0; j < operators.length; j++){
    for(k = 0; k < operators[j].syntax.length; k++){
      var sbstr = expression.substring(i, i+operators[j].syntax.length);
      
      if(sbstr == operators[j].syntax){
        console.log("found operator: " + operators[j].syntax);
        return true;
      }
    }  
  }
  return false;
}
function expression_is_space(expression, i){
  return expression[i] == ' ';
}
function expression_is_variable(expression, i){
  return expression[i].match(/[A-Za-z]/g);
}
function expression_is_nested_expression(expression, i){
  return expression[i] == '(';
}
function expression_get_operator(expression, i){
  for(j = 0; j < operators.length; j++){
    for(k = 0; k < operators[j].syntax.length; k++){
      var sbstr = expression.substring(i, i+operators[j].syntax.length);
      if(sbstr == operators[j].syntax){
        // console.log("got operator: " + operators[j].syntax);
        return operators[j];
      }
    }  
  }  
  // console.log("error: operator not found!")
}
function expression_get_variable(expression, i){
  var variable_name = new String('');
  for(j = i; j < expression.length; j++){
    if(expression[j].match(/[A-Za-z]/g)){
      variable_name += expression[j];
    }else{
      break;
    }
  }
  // console.log("got name: " + variable_name);
  return variable_name;
}



function variable_resolve(variable_name, variables){
  for(i = 0; i < variables.length; i++){
    if(variable_name == variables[i].name){
      return variables[i];
    }
  }
  console.log("error: unable to resolve " + variable_name);
  return null;
}

function isVariable(element){
  return element.constructor == Variable;
}

function isArray(element){
  return element.constructor == Array;
}

function isOperator(element){
  return element.constructor == Operator;
}

function hasPriority(element, cur){
  return element.priority == cur;
}


function scope_check_syntax(scope, operators){
 
  var cs = scope;
  
  // resolve all variables in the array
  for(i = 0; i < scope.length; i++){ 
    if(isArray(cs[i])){
      cs[i] = scope_check_syntax(cs[i], operators);
      console.log("array found!");
    } else if (isVariable(check_scope[i])){
      cs[i] = cs[i].type;
      console.log(cs);
    }
  }
  
  var has_operator = true;
  var priority = 0;
  
  while(has_operator){
    has_operator = false;
    
    for(i = 0; i < cs.length; i++){
      if(isOperator(cs[i]) && hasPriority(cs[i], priority)){
        var op_pos;
        for(j = 0; j < cs[i].input.length; j++){
          if(cs[i].input[j] == null){
            op_pos = j;
          } 
        } 
        
        if(cs[i].length < cs[i].input.length){
          console.log("error: input too shot, expected ("   + 
          cs[i].input.length                                + 
          ")"                                               + 
          ", recieved ("                                    + 
          cs[i].length                                      + 
          ")");
        }
        
        for(j = 0; j < cs[i].input.length; j++){
          console.log(cs[j] + " with " + cs[i].input[j]);
          
        }
        
      }
      
      
    }
    
    priority++;
  }
  
    
}

function expression_evaluate(expression, variables, operators, start){
  var length = expression_get_length(expression, start);
  var i = start;
  var clipped_expression = expression.substring(start, start+length);
  // console.log("open (\"" + clipped_expression +"\") -> [" + start + ", " + (start+length) + ", " + length + "]");
  var expect_parenthesis = false;
  
  if(expression[start] == '('){
    expect_parenthesis = true;
    i++;
  }
  
  var scope = [];
  for(; i < start+length; i++){
     console.log("parsing (" + i + "): " + expression[i]);
    
    if(expression_is_nested_expression(expression, i)){
      console.log("nested expression found jumping to " + "(\"" + expression[i] + "\")");
      scope.push(expression_evaluate(expression, variables, operators, i)); //scope.push();
      i += expression_get_length(expression, i);
      
      
    }else if(expression_is_operator(expression, i)){
      var operator = expression_get_operator(expression, i);
      scope.push(operator);
      i += operator.syntax.length;
      console.log("operator found: jumping to " + i + "(\"" + expression[i] + "\")");
      
    }else if(expression_is_variable(expression, i)){
      var variable_name = expression_get_variable(expression, i);
      var variable = variable_resolve(variable_name, variables);
      scope.push(variable);
      i += variable_name.length;
      console.log("variable found: jumping to " + i + "(\"" + expression[i] + "\")");
      
    }else if(expression_is_space(expression, i)){
      console.log("skipping " + i + " (\"" + expression[i] + "\")");
      continue;
    }else{
      console.log("no fucking clue what " + expression[i] + " is.");
    }
  }
  
  // scope_evaluate(scope, operators);
  
  // console.log("close (\"" + clipped_expression +"\")");
  
  
  return scope;
}


function truth_table_make_variables(variable_names){
  var variables = [];
  for(i = 0; i < variable_names.length; i++){
    variables.push(new Variable(variable_names[i], Boolean, false));
  }
  return variables;
}

function truth_table_next_row(variables){
  
}

function truth_table_get_variables(expression){
  return expression.match(/[A-Za-z]+/g);
}

function truth_table(expression){
    console.log("\n---Fetching Variable Names---");
    var variable_names = truth_table_get_variables(expression);
    console.log("Names: " + variable_names);
    
    console.log("\n---Creating Variables---");
    var variables = truth_table_make_variables(variable_names);
		console.log("Variables: ");
		console.log(variables);
		
		console.log("\n---Rendering Expression---");
		var scope = expression_evaluate(expression, variables, operators, 0);
    
    console.log("\n---Checking Syntax---");
    scope_check_syntax(scope);
    
}




truth_table("((A && B) || (D || C))");
