class Operator {

	constructor(priority, syntax, func, input, output){
		this.priority   = priority;
		this.syntax     = syntax;
		this.func   	  = func;
		this.input 	    = input;
		this.output 	  = output;
		
	}

}

function nand (a, b)  {return !(a & b);                 }
function and  (a, b)  {return a && b;                   }
function xor  (a, b)  {return ( a || b ) && !( a && b );}
function or   (a, b)  {return a || b;                   }
function not  (a)     {return !a;                       }

var operator_nand = new Operator(2, "!&", nand, [Boolean, null, Boolean], Boolean);
var operator_and =  new Operator(2, "&&", and, [Boolean, null, Boolean],  Boolean);
var operator_xor =  new Operator(2, "||", xor, [Boolean, null, Boolean],  Boolean);
var operator_or =   new Operator(2, "|", or, [Boolean, null, Boolean],    Boolean);
var operator_not =  new Operator(1, "!", not, [null, Boolean],            Boolean);

var operators = [];
operators.push(operator_nand);
operators.push(operator_and);
operators.push(operator_xor);
operators.push(operator_or);
operators.push(operator_not);

class Variable {
  
  constructor(name, type, value){
    this.name = name;
    this.type = type;
    this.value = value;
  }
  
}





function expression_execute(expression, variables){
  
}

function expression_get_length(expression, start){
  if(expression[start] == '('){
    
    var counter = 0;
    var i = start;
    
    do{
      
      if(expression[i] == '('){
        counter++;
      }else if(expression[i] == ')'){
        counter--;
      }
      i++
    }while(!(counter == 0) && (i < expression.length));
    
    if(counter === 0){
      return i-start;
    }else{
      console.log("error: no closing parenthesis at " + start);  
    }
    
  }else{
    return expression.length - start;
  }
}
function print_se(start, length){
  console.log("[" + start + "," + (start+length) + "] -> " + length);
}

// assumes sorted from max length min length
function expression_is_operator(expression, i){
  for(j = 0; j < operators.length; j++){
    for(k = 0; k < operators[j].syntax.length; k++){
      var sbstr = expression.substring(i, i+operators[j].syntax.length);
      
      if(sbstr == operators[j].syntax){
        console.log("found operator: " + operators[j].syntax);
        return true;
      }
    }  
  }
  return false;
}
function expression_is_space(expression, i){
  return expression[i] == ' ';
}
function expression_is_variable(expression, i){
  return expression[i].match(/[A-Za-z]/g);
}
function expression_is_nested_expression(expression, i){
  return expression[i] == '(';
}
function expression_get_operator(expression, i){
  for(j = 0; j < operators.length; j++){
    for(k = 0; k < operators[j].syntax.length; k++){
      var sbstr = expression.substring(i, i+operators[j].syntax.length);
      if(sbstr == operators[j].syntax){
        // console.log("got operator: " + operators[j].syntax);
        return operators[j];
      }
    }  
  }  
  // console.log("error: operator not found!")
}
function expression_get_variable(expression, i){
  var variable_name = new String('');
  for(j = i; j < expression.length; j++){
    if(expression[j].match(/[A-Za-z]/g)){
      variable_name += expression[j];
    }else{
      break;
    }
  }
  // console.log("got name: " + variable_name);
  return variable_name;
}



function variable_resolve(variable_name, variables){
  for(i = 0; i < variables.length; i++){
    if(variable_name == variables[i].name){
      return variables[i];
    }
  }
  console.log("error: unable to resolve " + variable_name);
  return null;
}

function isVariable(element){
  return element instanceof Variable;
}

function isArray(element){
  return element instanceof Array;
}

function isOperator(element){
  return element instanceof Operator;
}


function compilerException(location, expected){
  this.name = "compilerException";
  this.location = location;
  this.expected = expected;
}

function hasPriority(element, i){
  if(isOperator(element)){  
    return element.priority == i;
  }else{
    throw compilerException("hasPriority()", 
                            "element is an operator");
  }
}

function syntaxException(message, actual, expected){
  this.name = "Syntax Exception";
  this.message = message;
  this.expected = expected;
  this.actual = actual;
}

function isVariableSameAsType(variable, type){
    return variable instanceof type;
}

function scope_check_syntax(scope, operators, n=1){
 
  console.log("scope_check_syntax(n = " + n + ")");
  
  console.log(scope);
  
  if(scope.length == 1){
    return scope[0];
  }

  
  // all variables to types recursivly
  for(i = 0; i < scope.length; i++){ 
    
    if(isArray(scope[i])){
      // TODO: try catch
      scope[i] = scope_check_syntax(scope[i], operators, n+1);
       
    } else if (isVariable(scope[i])){
      scope[i] = scope[i].type;
      console.log(scope);
    }
  }
  
  //console.log("has_scope()");
  
  var has_operator = true;
  var priority = 0;

  
  while(has_operator){
    has_operator = false;
    
    // Find the operator in the scope
    for(i = 0; i < scope.length; i++){
      
      if(isOperator(scope[i])){
        has_operator = true;
      }
      
      
      if(isOperator(scope[i]) && hasPriority(scope[i], priority)){
        
        //console.log("found operator");
        
        // (i) is the operators positon in the scope
        // (operator_position) is the positon in the operators syntax
        var operator_position; 
        var operator_length = scope[i].input.length; 
        
        // we need the syntax for the opeator
        // e.g. "True   ==   Bool"
        // or   [Bool][Null][Bool]
        //        0     1     2
        //      operator_length    :3
        //      operator_position  :1
        for(j = 0; j < operator_length; j++){
          if(scope[i].input[j] == null){
            operator_position = j;
            break;
          } 
        } 
        //console.log("operator_length:" + operator_length);
        //console.log("operator_position:" + operator_position);
        
        // we check that we have enough arguments for the opeator
        // Expected: [Bool][Null][Bool]
        // Actual:   [Bool][Null]
        var scope_length = scope.length;
        if(scope_length < operator_length){
          throw syntaxException("too few arguments for " + cs[i].syntax, 
                                "requires "              + cs[i].operator_length,
                                "has "                   + scope_length);
        }
        //console.log("scope_length:" + scope_length);
        
        // we check that the operators have order of the syntax is good
        // Expected: [Bool][Null][Bool] -> i - operator_position = 1 - 1 =  0
        // Actual:   [Null][Bool][Bool] -> i - operator_position = 0 - 1 = -1
        var start_position = i - operator_position;
        if(start_position < 0){
          throw syntaxException("incorrect syntax for the operator", "", "");
        }
        //console.log("start_position:" + start_position);
        
        // we check that the operators syntax matches the expression
        // Expected: [Bool][Null][Bool]
        // Actual:   [Int][Bool][Null]
        // cs[i] is the operator that we're working on
        for(j = 0; j < operator_length; j++){
          //console.log(j + " (start)");
          
          if(scope[i].input[j] == null){
            // Expect: [==]
            if(!scope[i] === scope[j+start_position]){
              // Actual: [Bool]
              throw compilerException(
                "scope_check_syntax()",
                "never will be executed",
                "was executed");
            }
          
          }else{
            
            // Expect: [Bool]
            if(!scope[j+start_position] === scope[i].input[j]){
              //Actual: ![Bool]
              console.log("incorrect argument");
              throw syntaxException(
                "incorrect argument", scope[i].input[j], typeof scope[j+start_position]);
            }else{
              // Actual: [Bool]
            }
          } 
          
        }
        
        //replace the input(s) with the output
        var output = scope[i].output;
        var spliced = scope.splice(start_position, scope_length, output);
      
      }
      
      
    }
    
    priority++;
  }
  
  console.log(scope);
      
  return scope;
    
}

function expression_evaluate(expression, variables, operators, start){
  var length = expression_get_length(expression, start);
  var i = start;
  var clipped_expression = expression.substring(start, start+length);
  // console.log("open (\"" + clipped_expression +"\") -> [" + start + ", " + (start+length) + ", " + length + "]");
  var expect_parenthesis = false;
  
  if(expression[start] == '('){
    expect_parenthesis = true;
    i++;
  }
  
  var scope = [];
  for(; i < start+length; i++){
     console.log("parsing (" + i + "): " + expression[i]);
    
    if(expression_is_nested_expression(expression, i)){
      console.log("nested expression found jumping to " + "(\"" + expression[i] + "\")");
      scope.push(expression_evaluate(expression, variables, operators, i)); //scope.push();
      i += expression_get_length(expression, i);
      
      
    }else if(expression_is_operator(expression, i)){
      var operator = expression_get_operator(expression, i);
      scope.push(operator);
      i += operator.syntax.length;
      console.log("operator found: jumping to " + i + "(\"" + expression[i] + "\")");
      
    }else if(expression_is_variable(expression, i)){
      var variable_name = expression_get_variable(expression, i);
      var variable = variable_resolve(variable_name, variables);
      scope.push(variable);
      i += variable_name.length;
      console.log("variable found: jumping to " + i + "(\"" + expression[i] + "\")");
      
    }else if(expression_is_space(expression, i)){
      console.log("skipping " + i + " (\"" + expression[i] + "\")");
      continue;
    }else{
      console.log("no fucking clue what " + expression[i] + " is.");
    }
  }
  
  // scope_evaluate(scope, operators);
  
  // console.log("close (\"" + clipped_expression +"\")");
  
  
  return scope;
}


function truth_table_make_variables(variable_names){
  var variables = [];
  for(i = 0; i < variable_names.length; i++){
    variables.push(new Variable(variable_names[i], Boolean, false));
  }
  return variables;
}

function truth_table_get_variables(expression){
  return expression.match(/[A-Za-z]+/g);
}

function execute_expression(expression, variables, values){
  
}

function truth_table(expression){
    console.log("\n---Fetching Variable Names---");
    var variable_names = truth_table_get_variables(expression);
    console.log("Names: " + variable_names);
    
    console.log("\n---Creating Variables---");
    var variables = truth_table_make_variables(variable_names);
		console.log("Variables: ");
		console.log(variables);
		
		console.log("\n---Rendering Expression---");
		var scope = expression_evaluate(expression, variables, operators, 0);
    
    console.log("\n---Checking Syntax---");
    
    try{
      var final = scope_check_syntax(scope, operators);
    }catch(error){
      
    }
    
    if(final === Boolean){
      
    }
    
    
}




truth_table("((A && B) || (D || C))");
